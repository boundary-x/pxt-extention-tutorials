<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="CAw3xl9C:(_4=?5/KQ0#" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="i}3#vV#Ox6V8#sQgK,q}"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace aiPonybot {&#13;" line1="    /**&#13;" line2="     * ---------------PCA9685-------------------&#13;" line3="     */&#13;" line4="    const PCA9685_ADDRESS = 0x40;&#13;" line5="    const MODE1 = 0x00;&#13;" line6="    const MODE2 = 0x01;&#13;" line7="    const SUBADR1 = 0x02;&#13;" line8="    const SUBADR2 = 0x03;&#13;" line9="    const SUBADR3 = 0x04;&#13;" line10="    const PRESCALE = 0xFE;&#13;" line11="    const LED0_ON_L = 0x06;&#13;" line12="    const LED0_ON_H = 0x07;&#13;" line13="    const LED0_OFF_L = 0x08;&#13;" line14="    const LED0_OFF_H = 0x09;&#13;" line15="    const ALL_LED_ON_L = 0xFA;&#13;" line16="    const ALL_LED_ON_H = 0xFB;&#13;" line17="    const ALL_LED_OFF_L = 0xFC;&#13;" line18="    const ALL_LED_OFF_H = 0xFD;&#13;" line19="&#13;" line20="    const STP_CHA_L = 2047;&#13;" line21="    const STP_CHA_H = 4095;&#13;" line22="    const STP_CHB_L = 1;&#13;" line23="    const STP_CHB_H = 2047;&#13;" line24="    const STP_CHC_L = 1023;&#13;" line25="    const STP_CHC_H = 3071;&#13;" line26="    const STP_CHD_L = 3071;&#13;" line27="    const STP_CHD_H = 1023;&#13;" line28="&#13;" line29="    const BYG_CHA_L = 3071;&#13;" line30="    const BYG_CHA_H = 1023;&#13;" line31="    const BYG_CHB_L = 1023;&#13;" line32="    const BYG_CHB_H = 3071;&#13;" line33="    const BYG_CHC_L = 4095;&#13;" line34="    const BYG_CHC_H = 2047;&#13;" line35="    const BYG_CHD_L = 2047;&#13;" line36="    const BYG_CHD_H = 4095;&#13;" line37="&#13;" line38="    export enum Mecanum {&#13;" line39="        //% block=&quot;↖&quot;&#13;" line40="        LeftForward = 1,&#13;" line41="        //% block=&quot;↑&quot;&#13;" line42="        Forward = 2,&#13;" line43="        //% block=&quot;↗&quot;&#13;" line44="        RightForward = 3,&#13;" line45="        //% block=&quot;←&quot;&#13;" line46="        Left = 4,&#13;" line47="        //% block=&quot;s&quot;&#13;" line48="        Stop = 5,&#13;" line49="        //% block=&quot;→&quot;&#13;" line50="        Right = 6,&#13;" line51="        //% block=&quot;↙&quot;&#13;" line52="        LeftBackward = 7,&#13;" line53="        //% block=&quot;↓&quot;&#13;" line54="        Backward = 8,&#13;" line55="        //% block=&quot;↘&quot;&#13;" line56="        RightBackward = 9&#13;" line57="    }&#13;" line58="&#13;" line59="    export enum DirectionControl {&#13;" line60="        //% block=&quot;↑&quot;&#13;" line61="        Forward = 1,&#13;" line62="        //% block=&quot;↓&quot;&#13;" line63="        Backward = 2,&#13;" line64="        //% block=&quot;↶&quot;&#13;" line65="        Clockwise = 3,&#13;" line66="        //% block=&quot;↷&quot;&#13;" line67="        CounterClockwise = 4,&#13;" line68="    }&#13;" line69="&#13;" line70="    export enum Stepper {&#13;" line71="        //% block=&quot;42&quot;&#13;" line72="        Stepper42 = 1,&#13;" line73="        //% block=&quot;28&quot;&#13;" line74="        Stepper28 = 2&#13;" line75="    }&#13;" line76="&#13;" line77="    export enum Servo {&#13;" line78="        //% block=&quot;서보 1&quot;&#13;" line79="        Servo1 = 0x01,&#13;" line80="        //% block=&quot;서보 2&quot;&#13;" line81="        Servo2 = 0x02,&#13;" line82="        //% block=&quot;서보 3&quot;&#13;" line83="        Servo3 = 0x03,&#13;" line84="        //% block=&quot;서보 4&quot;&#13;" line85="        Servo4 = 0x04,&#13;" line86="        //% block=&quot;서보 5&quot;&#13;" line87="        Servo5 = 0x05,&#13;" line88="        //% block=&quot;서보 6&quot;&#13;" line89="        Servo6 = 0x06,&#13;" line90="        //% block=&quot;서보 7&quot;&#13;" line91="        Servo7 = 0x07,&#13;" line92="        //% block=&quot;서보 8&quot;&#13;" line93="        Servo8 = 0x08&#13;" line94="    }&#13;" line95="&#13;" line96="    export enum Motor {&#13;" line97="        //% block=&quot;모터 1&quot;&#13;" line98="        Motor1 = 0x1,&#13;" line99="        //% block=&quot;모터 2&quot;&#13;" line100="        Motor2 = 0x2,&#13;" line101="        //% block=&quot;모터 3&quot;&#13;" line102="        Motor3 = 0x3,&#13;" line103="        //% block=&quot;모터 4&quot;&#13;" line104="        Motor4 = 0x4&#13;" line105="    }&#13;" line106="&#13;" line107="    export enum Direction {&#13;" line108="        //% blockId=&quot;정회전&quot; block=&quot;정회전&quot;&#13;" line109="        Clockwise = 1,&#13;" line110="        //% blockId=&quot;역회전&quot; block=&quot;역회전&quot;&#13;" line111="        CounterClockwise = -1,&#13;" line112="    }&#13;" line113="&#13;" line114="    export enum StepperPair {&#13;" line115="        Motors1And2 = 0x1,&#13;" line116="        Motors3And4 = 0x2&#13;" line117="    }&#13;" line118="&#13;" line119="    let initialized = false;&#13;" line120="&#13;" line121="    function i2cWrite(address: number, register: number, value: number) {&#13;" line122="        let buffer = pins.createBuffer(2);&#13;" line123="        buffer[0] = register;&#13;" line124="        buffer[1] = value;&#13;" line125="        pins.i2cWriteBuffer(address, buffer);&#13;" line126="    }&#13;" line127="&#13;" line128="    function i2cCmd(address: number, value: number) {&#13;" line129="        let buffer2 = pins.createBuffer(1);&#13;" line130="        buffer2[0] = value;&#13;" line131="        pins.i2cWriteBuffer(address, buffer2);&#13;" line132="    }&#13;" line133="&#13;" line134="    function i2cRead(address: number, register: number) {&#13;" line135="        pins.i2cWriteNumber(address, register, NumberFormat.UInt8BE);&#13;" line136="        let value = pins.i2cReadNumber(address, NumberFormat.UInt8BE);&#13;" line137="        return value;&#13;" line138="    }&#13;" line139="&#13;" line140="    function initPCA9685(): void {&#13;" line141="        i2cWrite(PCA9685_ADDRESS, MODE1, 0x00);&#13;" line142="        setFreq(50);&#13;" line143="        initialized = true;&#13;" line144="    }&#13;" line145="&#13;" line146="    function setFreq(frequency: number): void {&#13;" line147="        let prescaleValue = 25000000;&#13;" line148="        prescaleValue /= 4096;&#13;" line149="        prescaleValue /= frequency;&#13;" line150="        prescaleValue -= 1;&#13;" line151="        let prescale = prescaleValue;&#13;" line152="        let oldMode = i2cRead(PCA9685_ADDRESS, MODE1);&#13;" line153="        let newMode = (oldMode &amp; 0x7F) | 0x10; // sleep&#13;" line154="        i2cWrite(PCA9685_ADDRESS, MODE1, newMode); // go to sleep&#13;" line155="        i2cWrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler&#13;" line156="        i2cWrite(PCA9685_ADDRESS, MODE1, oldMode);&#13;" line157="        control.waitMicros(5000);&#13;" line158="        i2cWrite(PCA9685_ADDRESS, MODE1, oldMode | 0xa1);&#13;" line159="    }&#13;" line160="&#13;" line161="    function setPwm(channel: number, on: number, off: number): void {&#13;" line162="        if (channel &lt; 0 || channel &gt; 15) return;&#13;" line163="&#13;" line164="        let buffer3 = pins.createBuffer(5);&#13;" line165="        buffer3[0] = LED0_ON_L + 4 * channel;&#13;" line166="        buffer3[1] = on &amp; 0xff;&#13;" line167="        buffer3[2] = (on &gt;&gt; 8) &amp; 0xff;&#13;" line168="        buffer3[3] = off &amp; 0xff;&#13;" line169="        buffer3[4] = (off &gt;&gt; 8) &amp; 0xff;&#13;" line170="        pins.i2cWriteBuffer(PCA9685_ADDRESS, buffer3);&#13;" line171="    }&#13;" line172="&#13;" line173="    function setStepper28(index: number, direction: boolean): void {&#13;" line174="        if (index == 1) {&#13;" line175="            if (direction) {&#13;" line176="                setPwm(4, STP_CHA_L, STP_CHA_H);&#13;" line177="                setPwm(6, STP_CHB_L, STP_CHB_H);&#13;" line178="                setPwm(5, STP_CHC_L, STP_CHC_H);&#13;" line179="                setPwm(7, STP_CHD_L, STP_CHD_H);&#13;" line180="            } else {&#13;" line181="                setPwm(7, STP_CHA_L, STP_CHA_H);&#13;" line182="                setPwm(5, STP_CHB_L, STP_CHB_H);&#13;" line183="                setPwm(6, STP_CHC_L, STP_CHC_H);&#13;" line184="                setPwm(4, STP_CHD_L, STP_CHD_H);&#13;" line185="            }&#13;" line186="        } else {&#13;" line187="            if (direction) {&#13;" line188="                setPwm(0, STP_CHA_L, STP_CHA_H);&#13;" line189="                setPwm(2, STP_CHB_L, STP_CHB_H);&#13;" line190="                setPwm(1, STP_CHC_L, STP_CHC_H);&#13;" line191="                setPwm(3, STP_CHD_L, STP_CHD_H);&#13;" line192="            } else {&#13;" line193="                setPwm(3, STP_CHA_L, STP_CHA_H);&#13;" line194="                setPwm(1, STP_CHB_L, STP_CHB_H);&#13;" line195="                setPwm(2, STP_CHC_L, STP_CHC_H);&#13;" line196="                setPwm(0, STP_CHD_L, STP_CHD_H);&#13;" line197="            }&#13;" line198="        }&#13;" line199="    }&#13;" line200="&#13;" line201="    function setStepper42(index: number, direction: boolean): void {&#13;" line202="        if (index == 1) {&#13;" line203="            if (direction) {&#13;" line204="                setPwm(7, BYG_CHA_L, BYG_CHA_H);&#13;" line205="                setPwm(6, BYG_CHB_L, BYG_CHB_H);&#13;" line206="                setPwm(5, BYG_CHC_L, BYG_CHC_H);&#13;" line207="                setPwm(4, BYG_CHD_L, BYG_CHD_H);&#13;" line208="            } else {&#13;" line209="                setPwm(7, BYG_CHC_L, BYG_CHC_H);&#13;" line210="                setPwm(6, BYG_CHD_L, BYG_CHD_H);&#13;" line211="                setPwm(5, BYG_CHA_L, BYG_CHA_H);&#13;" line212="                setPwm(4, BYG_CHB_L, BYG_CHB_H);&#13;" line213="            }&#13;" line214="        } else {&#13;" line215="            if (direction) {&#13;" line216="                setPwm(3, BYG_CHA_L, BYG_CHA_H);&#13;" line217="                setPwm(2, BYG_CHB_L, BYG_CHB_H);&#13;" line218="                setPwm(1, BYG_CHC_L, BYG_CHC_H);&#13;" line219="                setPwm(0, BYG_CHD_L, BYG_CHD_H);&#13;" line220="            } else {&#13;" line221="                setPwm(3, BYG_CHC_L, BYG_CHC_H);&#13;" line222="                setPwm(2, BYG_CHD_L, BYG_CHD_H);&#13;" line223="                setPwm(1, BYG_CHA_L, BYG_CHA_H);&#13;" line224="                setPwm(0, BYG_CHB_L, BYG_CHB_H);&#13;" line225="            }&#13;" line226="        }&#13;" line227="    }&#13;" line228="&#13;" line229="    //% blockId=aiponybot_motor_servo block=&quot;|%index|서보모터|%degree|각도로 이동&quot;&#13;" line230="    //% weight=0&#13;" line231="    //% degree.min=0 degree.max=180&#13;" line232="    //% index.fieldEditor=&quot;gridpicker&quot; index.fieldOptions.columns=4&#13;" line233="    //% group=&quot;서보모터 제어&quot;&#13;" line234="    export function servo(index: Servo, degree: number): void {&#13;" line235="        if (!initialized) {&#13;" line236="            initPCA9685();&#13;" line237="        }&#13;" line238="        let microseconds = (degree * 1800 / 180 + 600); // 0.6ms ~ 2.4ms&#13;" line239="        let value2 = microseconds * 4096 / 20000;&#13;" line240="        setPwm(index + 7, 0, value2);&#13;" line241="    }&#13;" line242="&#13;" line243="    //% weight=0&#13;" line244="    //% blockId=aiponybot_motor_runMotor block=&quot;|%index|모터|%direction|방향|%speed|속도로 회전&quot;&#13;" line245="    //% speed.min=0 speed.max=255&#13;" line246="    //% index.fieldEditor=&quot;gridpicker&quot; index.fieldOptions.columns=2&#13;" line247="    //% direction.fieldEditor=&quot;gridpicker&quot; direction.fieldOptions.columns=2&#13;" line248="    //% group=&quot;모터 제어(심화)&quot;&#13;" line249="    export function runMotor(index: Motor, direction: Direction, speed: number): void {&#13;" line250="        if (!initialized) {&#13;" line251="            initPCA9685();&#13;" line252="        }&#13;" line253="        if (index === Motor.Motor3 || index === Motor.Motor4) {&#13;" line254="            direction = direction * -1 as Direction;&#13;" line255="        }&#13;" line256="        speed = speed * 16 * direction; // map 255 to 4096&#13;" line257="        if (speed &gt;= 4096) speed = 4095;&#13;" line258="        if (speed &lt;= -4096) speed = -4095;&#13;" line259="        if (index &gt; 4 || index &lt;= 0) return;&#13;" line260="        let positivePin = (4 - index) * 2;&#13;" line261="        let negativePin = (4 - index) * 2 + 1;&#13;" line262="        if (speed &gt;= 0) {&#13;" line263="            setPwm(positivePin, 0, 0);&#13;" line264="            setPwm(negativePin, 0, speed);&#13;" line265="        } else {&#13;" line266="            setPwm(positivePin, 0, -speed);&#13;" line267="            setPwm(negativePin, 0, -0);&#13;" line268="        }&#13;" line269="    }&#13;" line270="&#13;" line271="    //% weight=0&#13;" line272="    //% blockId=aiponybot_motor_runMecanum block=&quot;|메카넘|%direction|방향|%speed|속도로 이동&quot;&#13;" line273="    //% speed.min=0 speed.max=255&#13;" line274="    //% direction.fieldEditor=&quot;gridpicker&quot; direction.fieldOptions.columns=3&#13;" line275="    //% group=&quot;모터 제어(기초)&quot;&#13;" line276="    export function runMecanum(direction: Mecanum, speed: number): void {&#13;" line277="        if (!initialized) {&#13;" line278="            initPCA9685();&#13;" line279="        }&#13;" line280="        speed = speed * 16; // map 255 to 4096&#13;" line281="        if (speed &gt;= 4096) speed = 4095;&#13;" line282="        if (speed &lt;= -4096) speed = -4095;&#13;" line283="&#13;" line284="        switch (direction) {&#13;" line285="            case Mecanum.LeftForward: // ↖&#13;" line286="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward&#13;" line287="                setPwm(5, 0, 0); setPwm(4, 0, 0); // M2 stop&#13;" line288="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward&#13;" line289="                setPwm(1, 0, 0); setPwm(0, 0, 0); // M4 stop&#13;" line290="                break;&#13;" line291="            case Mecanum.Forward: // ↑&#13;" line292="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward&#13;" line293="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward&#13;" line294="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward&#13;" line295="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward&#13;" line296="                break;&#13;" line297="            case Mecanum.RightForward: // ↗&#13;" line298="                setPwm(7, 0, 0); setPwm(6, 0, 0); // M1 stop&#13;" line299="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward&#13;" line300="                setPwm(3, 0, 0); setPwm(2, 0, 0); // M3 stop&#13;" line301="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward&#13;" line302="                break;&#13;" line303="            case Mecanum.Left: // ←&#13;" line304="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward&#13;" line305="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward&#13;" line306="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward&#13;" line307="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward&#13;" line308="                break;&#13;" line309="            case Mecanum.Stop: // s&#13;" line310="                setPwm(7, 0, 0); setPwm(6, 0, 0); // M1 stop&#13;" line311="                setPwm(5, 0, 0); setPwm(4, 0, 0); // M2 stop&#13;" line312="                setPwm(3, 0, 0); setPwm(2, 0, 0); // M3 stop&#13;" line313="                setPwm(1, 0, 0); setPwm(0, 0, 0); // M4 stop&#13;" line314="                break;&#13;" line315="            case Mecanum.Right: // →&#13;" line316="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward&#13;" line317="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward&#13;" line318="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward&#13;" line319="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward&#13;" line320="                break;&#13;" line321="            case Mecanum.LeftBackward: // ↙&#13;" line322="                setPwm(7, 0, 0); setPwm(6, 0, 0); // M1 stop&#13;" line323="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward&#13;" line324="                setPwm(3, 0, 0); setPwm(2, 0, 0); // M3 stop&#13;" line325="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward&#13;" line326="                break;&#13;" line327="            case Mecanum.Backward: // ↓&#13;" line328="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward&#13;" line329="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward&#13;" line330="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward&#13;" line331="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward&#13;" line332="                break;&#13;" line333="            case Mecanum.RightBackward: // ↘&#13;" line334="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward&#13;" line335="                setPwm(5, 0, 0); setPwm(4, 0, 0); // M2 stop&#13;" line336="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward&#13;" line337="                setPwm(1, 0, 0); setPwm(0, 0, 0); // M4 stop&#13;" line338="                break;&#13;" line339="        }&#13;" line340="    }&#13;" line341="&#13;" line342="    //% weight=0&#13;" line343="    //% blockId=aiponybot_motor_stopMotor block=&quot;|%index|모터 정지&quot;&#13;" line344="    //% index.fieldEditor=&quot;gridpicker&quot; index.fieldOptions.columns=2 &#13;" line345="    //% group=&quot;모터 제어(심화)&quot;&#13;" line346="    export function stopMotor(index: Motor) {&#13;" line347="        setPwm((4 - index) * 2, 0, 0);&#13;" line348="        setPwm((4 - index) * 2 + 1, 0, 0);&#13;" line349="    }&#13;" line350="&#13;" line351="    //% weight=20&#13;" line352="    //% blockId=aiponybot_motor_stopAllMotors block=&quot;|모든 모터 정지&quot;&#13;" line353="    //% group=&quot;모터 제어(기초)&quot;&#13;" line354="    export function stopAllMotors(): void {&#13;" line355="        for (let idx = 1; idx &lt;= 4; idx++) {&#13;" line356="            stopMotor(idx as Motor);&#13;" line357="        }&#13;" line358="    }&#13;" line359="&#13;" line360="    //% weight=0&#13;" line361="    //% blockId=aiponybot_motor_runNormal block=&quot;|포니봇|%direction|방향|%speed|속도로 이동&quot;&#13;" line362="    //% speed.min=0 speed.max=255&#13;" line363="    //% direction.fieldEditor=&quot;gridpicker&quot; direction.fieldOptions.columns=2&#13;" line364="    //% group=&quot;모터 제어(기초)&quot;&#13;" line365="    export function runNormal(direction: DirectionControl, speed: number): void {&#13;" line366="        if (!initialized) {&#13;" line367="            initPCA9685();&#13;" line368="        }&#13;" line369="        speed = speed * 16; // map 255 to 4096&#13;" line370="        if (speed &gt;= 4096) speed = 4095;&#13;" line371="        if (speed &lt;= -4096) speed = -4095;&#13;" line372="&#13;" line373="        switch (direction) {&#13;" line374="            case DirectionControl.Forward: // ↑&#13;" line375="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward&#13;" line376="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward&#13;" line377="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward&#13;" line378="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward&#13;" line379="                break;&#13;" line380="            case DirectionControl.Backward: // ↓&#13;" line381="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward&#13;" line382="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward&#13;" line383="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward&#13;" line384="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward&#13;" line385="                break;&#13;" line386="            case DirectionControl.Clockwise: // ↶&#13;" line387="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward&#13;" line388="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward&#13;" line389="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward&#13;" line390="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward&#13;" line391="                break;&#13;" line392="            case DirectionControl.CounterClockwise: // ↷&#13;" line393="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward&#13;" line394="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward&#13;" line395="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward&#13;" line396="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward&#13;" line397="                break;&#13;" line398="        }&#13;" line399="    }&#13;" line400="&#13;" line401="    /**&#13;" line402="     * ---------------line sensor-------------------&#13;" line403="     */&#13;" line404="    export enum TwoLineState {&#13;" line405="        //% block=&quot;◌ ◌ &quot; &#13;" line406="        OffOff = 0,&#13;" line407="        //% block=&quot;● ●&quot; &#13;" line408="        OnOn = 1,&#13;" line409="        //% block=&quot;● ◌&quot; &#13;" line410="        OnOff = 2,&#13;" line411="        //% block=&quot;◌ ●&quot; &#13;" line412="        OffOn = 3,&#13;" line413="    }&#13;" line414="&#13;" line415="    export enum LineState {&#13;" line416="        //% block=&quot;◌&quot; &#13;" line417="        Off = 0,&#13;" line418="        //% block=&quot;●&quot; &#13;" line419="        On = 1&#13;" line420="    }&#13;" line421="&#13;" line422="    export enum LineSensorChannel {&#13;" line423="        //% block=&quot;왼쪽&quot;&#13;" line424="        Left = 1,&#13;" line425="        //% block=&quot;오른쪽&quot;&#13;" line426="        Right = 2,&#13;" line427="    }&#13;" line428="&#13;" line429="    //% blockId=&quot;checkTwoLineState&quot;&#13;" line430="    //% block=&quot;두 라인 센서의 값이 %state&quot;&#13;" line431="    //% state.fieldEditor=&quot;gridpicker&quot; state.fieldOptions.columns=2&#13;" line432="    //% group=&quot;라인 감지 센서&quot;&#13;" line433="    //% weight=0&#13;" line434="    export function checkTwoLineState(state: TwoLineState): boolean {&#13;" line435="        const leftSensor = pins.digitalReadPin(DigitalPin.P16);&#13;" line436="        const rightSensor = pins.digitalReadPin(DigitalPin.P15);&#13;" line437="&#13;" line438="        switch (state) {&#13;" line439="            case TwoLineState.OffOff:&#13;" line440="                return leftSensor === 0 &amp;&amp; rightSensor === 0;&#13;" line441="            case TwoLineState.OnOn:&#13;" line442="                return leftSensor === 1 &amp;&amp; rightSensor === 1;&#13;" line443="            case TwoLineState.OnOff:&#13;" line444="                return leftSensor === 1 &amp;&amp; rightSensor === 0;&#13;" line445="            case TwoLineState.OffOn:&#13;" line446="                return leftSensor === 0 &amp;&amp; rightSensor === 1;&#13;" line447="            default:&#13;" line448="                return false;&#13;" line449="        }&#13;" line450="    }&#13;" line451="&#13;" line452="    //% blockId=&quot;checkSingleLineSensor&quot;&#13;" line453="    //% block=&quot;%channel 라인 센서의 값이 %state&quot;&#13;" line454="    //% channel.fieldEditor=&quot;gridpicker&quot; channel.fieldOptions.columns=2&#13;" line455="    //% state.fieldEditor=&quot;gridpicker&quot; state.fieldOptions.columns=2&#13;" line456="    //% group=&quot;라인 감지 센서&quot;&#13;" line457="    //% weight=0&#13;" line458="    export function checkSingleLineSensor(channel: LineSensorChannel, state: LineState): boolean {&#13;" line459="        const sensorValue = channel === LineSensorChannel.Left&#13;" line460="            ? pins.digitalReadPin(DigitalPin.P16)&#13;" line461="            : pins.digitalReadPin(DigitalPin.P15);&#13;" line462="        return sensorValue === state;&#13;" line463="    }&#13;" line464="&#13;" line465="    //% blockId=&quot;readLineSensor&quot;&#13;" line466="    //% block=&quot;%channel 라인 센서 값 읽기&quot;&#13;" line467="    //% channel.fieldEditor=&quot;gridpicker&quot; channel.fieldOptions.columns=2&#13;" line468="    //% group=&quot;라인 감지 센서&quot;&#13;" line469="    //% weight=0&#13;" line470="    export function readLineSensor(channel: LineSensorChannel): number {&#13;" line471="        return channel === LineSensorChannel.Left&#13;" line472="            ? pins.digitalReadPin(DigitalPin.P16)&#13;" line473="            : pins.digitalReadPin(DigitalPin.P15);&#13;" line474="    }&#13;" line475="&#13;" line476="    /**&#13;" line477="     * ---------------sonar sensor-------------------&#13;" line478="     */&#13;" line479="    export enum PingUnit {&#13;" line480="        //% block=&quot;마이크로초&quot;&#13;" line481="        MicroSeconds,&#13;" line482="        //% block=&quot;센티미터&quot;&#13;" line483="        Centimeters,&#13;" line484="        //% block=&quot;인치&quot;&#13;" line485="        Inches&#13;" line486="    }&#13;" line487="&#13;" line488="    //% blockId=aiponybot_sonar_ping&#13;" line489="    //% block=&quot;%unit 단위로 측정한 거리&quot;&#13;" line490="    //% unit.fieldEditor=&quot;gridpicker&quot; unit.fieldOptions.columns=2&#13;" line491="    //% group=&quot;거리 감지 센서&quot;&#13;" line492="    //% weight=0&#13;" line493="    export function ping(unit: PingUnit, maxCmDistance = 500): number {&#13;" line494="        const trigger = DigitalPin.P13; // Trig 핀 기본값&#13;" line495="        const echo = DigitalPin.P14; // Echo 핀 기본값&#13;" line496="        pins.setPull(trigger, PinPullMode.PullNone);&#13;" line497="        pins.digitalWritePin(trigger, 0);&#13;" line498="        control.waitMicros(2);&#13;" line499="        pins.digitalWritePin(trigger, 1);&#13;" line500="        control.waitMicros(10);&#13;" line501="        pins.digitalWritePin(trigger, 0);&#13;" line502="&#13;" line503="        const distance = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);&#13;" line504="&#13;" line505="        if (distance === 0) {&#13;" line506="            switch (unit) {&#13;" line507="                case PingUnit.Centimeters: return maxCmDistance;&#13;" line508="                case PingUnit.Inches: return Math.idiv(maxCmDistance * 100, 254);&#13;" line509="                default: return maxCmDistance * 58;&#13;" line510="            }&#13;" line511="        }&#13;" line512="&#13;" line513="        switch (unit) {&#13;" line514="            case PingUnit.Centimeters: return Math.idiv(distance, 58);&#13;" line515="            case PingUnit.Inches: return Math.idiv(distance, 148);&#13;" line516="            default: return distance;&#13;" line517="        }&#13;" line518="    }&#13;" line519="&#13;" line520="    /**&#13;" line521="     * ---------------color sensor-------------------&#13;" line522="     */&#13;" line523="    export enum DetectedColor {&#13;" line524="        //% block=&quot;빨간색&quot;&#13;" line525="        Red,&#13;" line526="        //% block=&quot;초록색&quot;&#13;" line527="        Green,&#13;" line528="        //% block=&quot;파란색&quot;&#13;" line529="        Blue,&#13;" line530="        //% block=&quot;노란색&quot;&#13;" line531="        Yellow&#13;" line532="    }&#13;" line533="&#13;" line534="    class Tcs3472 {&#13;" line535="        isSetup: boolean;&#13;" line536="        address: number;&#13;" line537="        leds: DigitalPin;&#13;" line538="&#13;" line539="        constructor(address: number) {&#13;" line540="            this.isSetup = false;&#13;" line541="            this.address = address;&#13;" line542="        }&#13;" line543="&#13;" line544="        setup(): void {&#13;" line545="            if (this.isSetup) return;&#13;" line546="            this.isSetup = true;&#13;" line547="            aiPonybot.smbus.writeByte(this.address, 0x80, 0x03); // Enable register: PON | AEN&#13;" line548="            aiPonybot.smbus.writeByte(this.address, 0x81, 0x2b); // Integration time: 103.2ms&#13;" line549="        }&#13;" line550="&#13;" line551="        setIntegrationTime(time: number): void {&#13;" line552="            this.setup();&#13;" line553="            time = Math.clamp(0, 255, time * 10 / 24);&#13;" line554="            aiPonybot.smbus.writeByte(this.address, 0x81, 255 - time);&#13;" line555="        }&#13;" line556="&#13;" line557="        light(): number {&#13;" line558="            return this.raw()[0]; // Clear channel 값 반환&#13;" line559="        }&#13;" line560="&#13;" line561="        rgb(): number[] {&#13;" line562="            let result: number[] = this.raw();&#13;" line563="            let clear: number = result.shift(); // Clear 값을 제거하고 저장&#13;" line564="            if (clear === 0) return [0, 0, 0]; // Clear가 0이면 기본값 반환&#13;" line565="            for (let index: number = 0; index &lt; result.length; index++) {&#13;" line566="                result[index] = result[index] * 255 / clear; // RGB 값을 Clear로 정규화&#13;" line567="            }&#13;" line568="            return result; // [R, G, B]&#13;" line569="        }&#13;" line570="&#13;" line571="        raw(): number[] {&#13;" line572="            this.setup();&#13;" line573="            try {&#13;" line574="                let result2: Buffer = aiPonybot.smbus.readBuffer(this.address, 0xb4, pins.sizeOf(NumberFormat.UInt16LE) * 4);&#13;" line575="                return aiPonybot.smbus.unpack(&quot;HHHH&quot;, result2); // [Clear, R, G, B]&#13;" line576="            } catch (e) {&#13;" line577="                return [0, 0, 0, 0]; // I2C 오류 시 기본값 반환&#13;" line578="            }&#13;" line579="        }&#13;" line580="    }&#13;" line581="&#13;" line582="    let colorSensor: Tcs3472 = new Tcs3472(0x29); // 기본 I2C 주소 0x29&#13;" line583="&#13;" line584="    //% blockId=aiponybot_color_tcs34725_get_light&#13;" line585="    //% block=&quot;밝기(B) 값 읽기&quot;&#13;" line586="    //% group=&quot;색상 감지 센서&quot;&#13;" line587="    export function getLight(): number {&#13;" line588="        return Math.round(colorSensor.light());&#13;" line589="    }&#13;" line590="&#13;" line591="    //% blockId=aiponybot_color_tcs34725_get_red&#13;" line592="    //% block=&quot;빨간색(R) 색상 값 읽기&quot;&#13;" line593="    //% group=&quot;색상 감지 센서&quot;&#13;" line594="    export function getRed(): number {&#13;" line595="        return Math.round(colorSensor.rgb()[0]);&#13;" line596="    }&#13;" line597="&#13;" line598="    //% blockId=aiponybot_color_tcs34725_get_green&#13;" line599="    //% block=&quot;초록색(G) 색상 값 읽기&quot;&#13;" line600="    //% group=&quot;색상 감지 센서&quot;&#13;" line601="    export function getGreen(): number {&#13;" line602="        return Math.round(colorSensor.rgb()[1]);&#13;" line603="    }&#13;" line604="&#13;" line605="    //% blockId=aiponybot_color_tcs34725_get_blue&#13;" line606="    //% block=&quot;파란색(B) 색상 값 읽기&quot;&#13;" line607="    //% group=&quot;색상 감지 센서&quot;&#13;" line608="    export function getBlue(): number {&#13;" line609="        return Math.round(colorSensor.rgb()[2]);&#13;" line610="    }&#13;" line611="&#13;" line612="    //% blockId=aiponybot_color_tcs34725_set_integration_time&#13;" line613="    //% block=&quot;색상 통합 시간을 %time ms로 설정&quot;&#13;" line614="    //% time.min=0 time.max=612 value.defl=500&#13;" line615="    //% group=&quot;색상 감지 센서&quot;&#13;" line616="    export function setColorIntegrationTime(time: number): void {&#13;" line617="        return colorSensor.setIntegrationTime(time);&#13;" line618="    }&#13;" line619="&#13;" line620="    //% blockId=aiponybot_color_sensor_is_color_advanced&#13;" line621="    //% block=&quot;감지된 색상이 %color (임계값 %threshold)&quot;&#13;" line622="    //% threshold.min=10 threshold.max=100 threshold.defl=40&#13;" line623="    //% group=&quot;색상 감지 센서&quot;&#13;" line624="    export function isColorAdvanced(color: DetectedColor, threshold: number = 40): boolean {&#13;" line625="        const rgb = colorSensor.rgb();&#13;" line626="        const red = rgb[0];&#13;" line627="        const green = rgb[1];&#13;" line628="        const blue = rgb[2];&#13;" line629="        const clear2 = colorSensor.light();&#13;" line630="&#13;" line631="        if (clear2 &lt; 100) return false;&#13;" line632="&#13;" line633="        const total = red + green + blue;&#13;" line634="        if (total === 0) return false;&#13;" line635="&#13;" line636="        const redRatio = red / total;&#13;" line637="        const greenRatio = green / total;&#13;" line638="        const blueRatio = blue / total;&#13;" line639="&#13;" line640="        const thresholdRatio = threshold / 255;&#13;" line641="&#13;" line642="        switch (color) {&#13;" line643="            case DetectedColor.Red:&#13;" line644="                return redRatio &gt; greenRatio + thresholdRatio &amp;&amp;&#13;" line645="                    redRatio &gt; blueRatio + thresholdRatio &amp;&amp;&#13;" line646="                    redRatio &gt; 0.4;&#13;" line647="            case DetectedColor.Green:&#13;" line648="                return greenRatio &gt; redRatio + thresholdRatio &amp;&amp;&#13;" line649="                    greenRatio &gt; blueRatio + thresholdRatio &amp;&amp;&#13;" line650="                    greenRatio &gt; 0.4;&#13;" line651="            case DetectedColor.Blue:&#13;" line652="                return blueRatio &gt; redRatio + thresholdRatio &amp;&amp;&#13;" line653="                    blueRatio &gt; greenRatio + thresholdRatio * 0.8 &amp;&amp;&#13;" line654="                    blueRatio &gt; 0.35;&#13;" line655="            case DetectedColor.Yellow:&#13;" line656="                return redRatio &gt; blueRatio + thresholdRatio &amp;&amp;&#13;" line657="                    greenRatio &gt; blueRatio + thresholdRatio &amp;&amp;&#13;" line658="                    Math.abs(redRatio - greenRatio) &lt; 0.1 &amp;&amp;&#13;" line659="                    redRatio + greenRatio &gt; 0.6;&#13;" line660="            default:&#13;" line661="                return false;&#13;" line662="        }&#13;" line663="    }&#13;" line664="&#13;" line665="    //% blockId=aiponybot_color_sensor_is_in_range&#13;" line666="    //% block=&quot;R: %minR ~ %maxR, G: %minG ~ %maxG, B: %minB ~ %maxB&quot;&#13;" line667="    //% minR.min=0 minR.max=255 minR.defl=0&#13;" line668="    //% maxR.min=0 maxR.max=255 maxR.defl=255&#13;" line669="    //% minG.min=0 minG.max=255 minG.defl=0&#13;" line670="    //% maxG.min=0 maxG.max=255 maxG.defl=255&#13;" line671="    //% minB.min=0 minB.max=255 minB.defl=0&#13;" line672="    //% maxB.min=0 maxB.max=255 maxB.defl=255&#13;" line673="    //% group=&quot;색상 감지 센서&quot;&#13;" line674="    //% inlineInputMode=inline&#13;" line675="    export function isColorInRange(minR: number, maxR: number, minG: number, maxG: number, minB: number, maxB: number): boolean {&#13;" line676="        const rgb2 = colorSensor.rgb();&#13;" line677="        const red2 = rgb2[0];&#13;" line678="        const green2 = rgb2[1];&#13;" line679="        const blue2 = rgb2[2];&#13;" line680="&#13;" line681="        return red2 &gt; minR &amp;&amp; red2 &lt; maxR &amp;&amp;&#13;" line682="            green2 &gt; minG &amp;&amp; green2 &lt; maxG &amp;&amp;&#13;" line683="            blue2 &gt; minB &amp;&amp; blue2 &lt; maxB;&#13;" line684="    }&#13;" line685="&#13;" line686="    /**&#13;" line687=" * ---------------oled display-------------------&#13;" line688=" */&#13;" line689="    const FONT_5X7 = hex`000000000000005F00000007000700147F147F14242A072A12231308646237495522500005030000001C2241000041221C00082A1C2A0808083E080800503000000808080808006060000020100804023E5149453E00427F400042615149462141454B311814127F1027454545393C4A49493001710905033649494936064949291E003636000000563600000008142241141414141441221408000201510906324979413E7E1111117E7F494949363E414141227F4141221C7F494949417F090901013E414151327F0808087F00417F41002040413F017F081422417F404040407F0204027F7F0408107F3E4141413E7F090909063E4151215E7F09192946464949493101017F01013F4040403F1F2040201F7F2018207F63140814630304780403615149454300007F4141020408102041417F000004020102044040404040000102040020545454787F484444383844444420384444487F3854545418087E090102081454543C7F0804047800447D40002040443D00007F10284400417F40007C041804787C0804047838444444387C14141408081414187C7C080404084854545420043F4440203C4040207C1C2040201C3C4030403C44281028440C5050503C4464544C44000836410000007F000000413608000201020402`;&#13;" line690="&#13;" line691="    export enum Display {&#13;" line692="        //% block=&quot;ON&quot;&#13;" line693="        On = 1,&#13;" line694="        //% block=&quot;OFF&quot;&#13;" line695="        Off = 0&#13;" line696="    }&#13;" line697="&#13;" line698="    const MIN_X = 0;&#13;" line699="    const MIN_Y = 0;&#13;" line700="    const MAX_X = 127;&#13;" line701="    const MAX_Y = 63;&#13;" line702="&#13;" line703="    let i2cAddress = 60;&#13;" line704="    let screen = pins.createBuffer(1025);&#13;" line705="    let buffer22 = pins.createBuffer(2);&#13;" line706="    let buffer32 = pins.createBuffer(3);&#13;" line707="    let buffer4 = pins.createBuffer(4);&#13;" line708="    let buffer7 = pins.createBuffer(7);&#13;" line709="    let buffer13 = pins.createBuffer(13);&#13;" line710="    buffer7[0] = 0x40;&#13;" line711="    buffer13[0] = 0x40;&#13;" line712="    let drawEnabled = 1;&#13;" line713="    let cursorX = 0;&#13;" line714="    let cursorY = 0;&#13;" line715="&#13;" line716="    let zoomEnabled = 0;&#13;" line717="    let doubleSize = 0;&#13;" line718="&#13;" line719="    function sendCommand1(data: number) {&#13;" line720="        let number = data % 256;&#13;" line721="        pins.i2cWriteNumber(i2cAddress, number, NumberFormat.UInt16BE);&#13;" line722="    }&#13;" line723="&#13;" line724="    function sendCommand2(data1: number, data2: number) {&#13;" line725="        buffer32[0] = 0;&#13;" line726="        buffer32[1] = data1;&#13;" line727="        buffer32[2] = data2;&#13;" line728="        pins.i2cWriteBuffer(i2cAddress, buffer32);&#13;" line729="    }&#13;" line730="&#13;" line731="    function sendCommand3(data1: number, data2: number, data3: number) {&#13;" line732="        buffer4[0] = 0;&#13;" line733="        buffer4[1] = data1;&#13;" line734="        buffer4[2] = data2;&#13;" line735="        buffer4[3] = data3;&#13;" line736="        pins.i2cWriteBuffer(i2cAddress, buffer4);&#13;" line737="    }&#13;" line738="&#13;" line739="    function setPosition(column: number = 0, page: number = 0) {&#13;" line740="        sendCommand1(0xb0 | page);&#13;" line741="        sendCommand1(0x00 | (column % 16));&#13;" line742="        sendCommand1(0x10 | (column &gt;&gt; 4));&#13;" line743="    }&#13;" line744="&#13;" line745="    function clearBit(data: number, bit: number): number {&#13;" line746="        if (data &amp; (1 &lt;&lt; bit)) data -= (1 &lt;&lt; bit);&#13;" line747="        return data;&#13;" line748="    }&#13;" line749="&#13;" line750="    function draw(data: number) {&#13;" line751="        if (data &gt; 0) {&#13;" line752="            setPosition();&#13;" line753="            pins.i2cWriteBuffer(i2cAddress, screen);&#13;" line754="        }&#13;" line755="    }&#13;" line756="&#13;" line757="    //% block=&quot;디스플레이 색상 반전 %on&quot;&#13;" line758="    //% blockGap=8&#13;" line759="    //% group=&quot;디스플레이 제어&quot;&#13;" line760="    //% on.shadow=&quot;toggleOnOff&quot;&#13;" line761="    //% weight=2&#13;" line762="    export function invert(on: boolean = true) {&#13;" line763="        let number2 = (on) ? 0xA7 : 0xA6;&#13;" line764="        sendCommand1(number2);&#13;" line765="    }&#13;" line766="&#13;" line767="    //% block=&quot;디스플레이 지우기&quot;&#13;" line768="    //% blockGap=8&#13;" line769="    //% group=&quot;디스플레이 제어&quot;&#13;" line770="    //% weight=3&#13;" line771="    export function clear() {&#13;" line772="        cursorX = cursorY = 0;&#13;" line773="        screen.fill(0);&#13;" line774="        screen[0] = 0x40;&#13;" line775="        draw(1);&#13;" line776="    }&#13;" line777="&#13;" line778="    //% block=&quot;디스플레이 화면 %on&quot;&#13;" line779="    //% on.defl=1&#13;" line780="    //% blockGap=8&#13;" line781="    //% group=&quot;디스플레이 제어&quot;&#13;" line782="    //% on.shadow=&quot;toggleOnOff&quot;&#13;" line783="    //% weight=1&#13;" line784="    export function display(on: boolean) {&#13;" line785="        if (on) sendCommand1(0xAF);&#13;" line786="        else sendCommand1(0xAE);&#13;" line787="    }&#13;" line788="&#13;" line789="    //% block=&quot;픽셀 출력 - 위치: x %x y %y, 색상: %color&quot;&#13;" line790="    //% x.max=127 x.min=0 x.defl=0&#13;" line791="    //% y.max=63 y.min=0 y.defl=0&#13;" line792="    //% color.max=1 color.min=0 color.defl=1&#13;" line793="    //% blockGap=8 inlineInputMode=inline&#13;" line794="    //% group=&quot;디스플레이 제어(도형)&quot;&#13;" line795="    //% weight=4&#13;" line796="    export function pixel(x: number, y: number, color: number = 1) {&#13;" line797="        let page = y &gt;&gt; 3;&#13;" line798="        let shiftPage = y % 8;&#13;" line799="        let index2 = x + page * 128 + 1;&#13;" line800="        let byte = (color) ? (screen[index2] | (1 &lt;&lt; shiftPage)) : clearBit(screen[index2], shiftPage);&#13;" line801="        screen[index2] = byte;&#13;" line802="    }&#13;" line803="&#13;" line804="    function drawChar(character: string, column: number, row: number, color: number = 1) {&#13;" line805="        let position = (Math.min(127, Math.max(character.charCodeAt(0), 32)) - 32) * 5;&#13;" line806="        let margin = 0;&#13;" line807="        let index3 = column + row * 128 + 1;&#13;" line808="&#13;" line809="        if (doubleSize) {&#13;" line810="            for (let i = 0; i &lt; 5; i++) {&#13;" line811="                let line = 0;&#13;" line812="                for (let j = 0; j &lt; 8; j++) {&#13;" line813="                    if (color &gt; 0 ? FONT_5X7[position + i] &amp; (1 &lt;&lt; j) : !(FONT_5X7[position + i] &amp; (1 &lt;&lt; j))) {&#13;" line814="                        pixel(column + margin, row * 8 + line);&#13;" line815="                        pixel(column + margin, row * 8 + line + 1);&#13;" line816="                        pixel(column + margin + 1, row * 8 + line);&#13;" line817="                        pixel(column + margin + 1, row * 8 + line + 1);&#13;" line818="                    }&#13;" line819="                    line += 2;&#13;" line820="                }&#13;" line821="                margin += 2;&#13;" line822="            }&#13;" line823="            let line2 = 0;&#13;" line824="            for (let k = 0; k &lt; 8; k++) {&#13;" line825="                if (color == 0) {&#13;" line826="                    pixel(column + 10, row * 8 + line2);&#13;" line827="                    pixel(column + 10, row * 8 + line2 + 1);&#13;" line828="                    pixel(column + 11, row * 8 + line2);&#13;" line829="                    pixel(column + 11, row * 8 + line2 + 1);&#13;" line830="                }&#13;" line831="                line2 += 2;&#13;" line832="            }&#13;" line833="        } else {&#13;" line834="            let l = 0;&#13;" line835="            for (let m = 0; m &lt; 5; m++) {&#13;" line836="                screen[index3 + m] = (color &gt; 0) ? FONT_5X7[position + m] : FONT_5X7[position + m] ^ 0xFF;&#13;" line837="                if (zoomEnabled) {&#13;" line838="                    buffer13[l + 1] = screen[index3 + m];&#13;" line839="                    buffer13[l + 2] = screen[index3 + m];&#13;" line840="                } else {&#13;" line841="                    buffer7[m + 1] = screen[index3 + m];&#13;" line842="                }&#13;" line843="                l += 2;&#13;" line844="            }&#13;" line845="            screen[index3 + 5] = (color &gt; 0) ? 0 : 0xFF;&#13;" line846="            if (zoomEnabled) {&#13;" line847="                buffer13[12] = screen[index3 + 5];&#13;" line848="            } else {&#13;" line849="                buffer7[6] = screen[index3 + 5];&#13;" line850="            }&#13;" line851="            setPosition(column, row);&#13;" line852="            if (zoomEnabled) {&#13;" line853="                pins.i2cWriteBuffer(i2cAddress, buffer13);&#13;" line854="            } else {&#13;" line855="                pins.i2cWriteBuffer(i2cAddress, buffer7);&#13;" line856="            }&#13;" line857="        }&#13;" line858="    }&#13;" line859="&#13;" line860="    //% block=&quot;문장 출력 - 내용: %text, 위치: %column열 %row행, 색상: %color&quot;&#13;" line861="    //% text.defl='AI ponybot'&#13;" line862="    //% column.max=120 column.min=0 column.defl=0&#13;" line863="    //% row.max=7 row.min=0 row.defl=0&#13;" line864="    //% color.max=1 color.min=0 color.defl=1&#13;" line865="    //% blockGap=8 inlineInputMode=inline&#13;" line866="    //% group=&quot;디스플레이 제어(데이터)&quot;&#13;" line867="    //% weight=1&#13;" line868="    export function showString(text: string, column: number, row: number, color: number = 1) {&#13;" line869="        let steps = doubleSize ? 12 : 6;&#13;" line870="        for (let n = 0; n &lt; text.length; n++) {&#13;" line871="            drawChar(text.charAt(n), column, row, color);&#13;" line872="            column += steps;&#13;" line873="        }&#13;" line874="        if (doubleSize) draw(1);&#13;" line875="    }&#13;" line876="&#13;" line877="    //% block=&quot;숫자 출력 - 내용: %number, 위치: %column열 %row행, 색상: %color&quot;&#13;" line878="    //% number.defl=777&#13;" line879="    //% column.max=120 column.min=0 column.defl=0&#13;" line880="    //% row.max=7 row.min=0 row.defl=0&#13;" line881="    //% color.max=1 color.min=0 color.defl=1&#13;" line882="    //% blockGap=8 inlineInputMode=inline&#13;" line883="    //% group=&quot;디스플레이 제어(데이터)&quot;&#13;" line884="    //% weight=3&#13;" line885="    export function showNumber(number: number, column: number, row: number, color: number = 1) {&#13;" line886="        showString(number.toString(), column, row, color);&#13;" line887="    }&#13;" line888="&#13;" line889="    function scroll() {&#13;" line890="        cursorX = 0;&#13;" line891="        cursorY += doubleSize ? 2 : 1;&#13;" line892="        if (cursorY &gt; 7) {&#13;" line893="            cursorY = 7;&#13;" line894="            screen.shift(128);&#13;" line895="            screen[0] = 0x40;&#13;" line896="            draw(1);&#13;" line897="        }&#13;" line898="    }&#13;" line899="&#13;" line900="    //% block=&quot;문장 출력 - 내용: %text, 줄바꿈: %newline&quot;&#13;" line901="    //% text.defl=&quot;AI ponybot&quot;&#13;" line902="    //% newline.defl=true&#13;" line903="    //% blockGap=8 inlineInputMode=inline&#13;" line904="    //% group=&quot;디스플레이 제어(데이터)&quot;&#13;" line905="    //% weight=2&#13;" line906="    export function printString(text: string, newline: boolean = true) {&#13;" line907="        let steps2 = doubleSize ? 12 : 6;&#13;" line908="        for (let o = 0; o &lt; text.length; o++) {&#13;" line909="            drawChar(text.charAt(o), cursorX, cursorY, 1);&#13;" line910="            cursorX += steps2;&#13;" line911="            if (cursorX &gt; 120) scroll();&#13;" line912="        }&#13;" line913="        if (newline) scroll();&#13;" line914="        if (doubleSize) draw(1);&#13;" line915="    }&#13;" line916="&#13;" line917="    //% block=&quot;숫자 출력 - 내용: %number, 줄바꿈: %newline&quot;&#13;" line918="    //% number.defl=&quot;777&quot;&#13;" line919="    //% newline.defl=true&#13;" line920="    //% weight=86 blockGap=8 inlineInputMode=inline&#13;" line921="    //% group=&quot;디스플레이 제어(데이터)&quot;&#13;" line922="    //% weight=4&#13;" line923="    export function printNumber(number: number, newline: boolean = true) {&#13;" line924="        printString(number.toString(), newline);&#13;" line925="    }&#13;" line926="&#13;" line927="    //% block=&quot;수평선 출력 - 위치: x %x y %y, 길이: %length, 색상: %color&quot;&#13;" line928="    //% x.max=127 x.min=0 x.defl=0&#13;" line929="    //% y.max=63 y.min=0 y.defl=0&#13;" line930="    //% length.max=128 length.min=1 length.defl=16&#13;" line931="    //% color.max=1 color.min=0 color.defl=1&#13;" line932="    //% blockGap=8 inlineInputMode=inline&#13;" line933="    //% group=&quot;디스플레이 제어(도형)&quot;&#13;" line934="    //% weight=2&#13;" line935="    export function horizontalLine(x: number, y: number, length: number, color: number = 1) {&#13;" line936="        let savedDraw = drawEnabled;&#13;" line937="        if ((y &lt; MIN_Y) || (y &gt; MAX_Y)) return;&#13;" line938="        drawEnabled = 0;&#13;" line939="        for (let p = x; p &lt; (x + length); p++)&#13;" line940="            if ((p &gt;= MIN_X) &amp;&amp; (p &lt;= MAX_X))&#13;" line941="                pixel(p, y, color);&#13;" line942="        drawEnabled = savedDraw;&#13;" line943="        draw(drawEnabled);&#13;" line944="    }&#13;" line945="&#13;" line946="    //% block=&quot;수직선 출력 - 위치: x %x y %y, 길이: %length, 색상: %color&quot;&#13;" line947="    //% x.max=127 x.min=0 x.defl=0&#13;" line948="    //% y.max=63 y.min=0 y.defl=0&#13;" line949="    //% length.max=128 length.min=1 length.defl=16&#13;" line950="    //% color.max=1 color.min=0 color.defl=1&#13;" line951="    //% blockGap=8 inlineInputMode=inline&#13;" line952="    //% group=&quot;디스플레이 제어(도형)&quot;&#13;" line953="    //% weight=1&#13;" line954="    export function verticalLine(x: number, y: number, length: number, color: number = 1) {&#13;" line955="        let savedDraw2 = drawEnabled;&#13;" line956="        drawEnabled = 0;&#13;" line957="        if ((x &lt; MIN_X) || (x &gt; MAX_X)) return;&#13;" line958="        for (let q = y; q &lt; (y + length); q++)&#13;" line959="            if ((q &gt;= MIN_Y) &amp;&amp; (q &lt;= MAX_Y))&#13;" line960="                pixel(x, q, color);&#13;" line961="        drawEnabled = savedDraw2;&#13;" line962="        draw(drawEnabled);&#13;" line963="    }&#13;" line964="&#13;" line965="    //% block=&quot;사각형 출력 - x1 %x1 y1 %y1 x2 %x2 y2 %y2, 색상: %color&quot;&#13;" line966="    //% color.defl=1&#13;" line967="    //% blockGap=8 inlineInputMode=inline&#13;" line968="    //% group=&quot;디스플레이 제어(도형)&quot;&#13;" line969="    //% weight=3&#13;" line970="    export function rectangle(x1: number, y1: number, x2: number, y2: number, color: number = 1) {&#13;" line971="        if (x1 &gt; x2) x1 = [x2, x2 = x1][0];&#13;" line972="        if (y1 &gt; y2) y1 = [y2, y2 = y1][0];&#13;" line973="        drawEnabled = 0;&#13;" line974="        horizontalLine(x1, y1, x2 - x1 + 1, color);&#13;" line975="        horizontalLine(x1, y2, x2 - x1 + 1, color);&#13;" line976="        verticalLine(x1, y1, y2 - y1 + 1, color);&#13;" line977="        verticalLine(x2, y1, y2 - y1 + 1, color);&#13;" line978="        drawEnabled = 1;&#13;" line979="        draw(1);&#13;" line980="    }&#13;" line981="&#13;" line982="    function initialize() {&#13;" line983="        sendCommand1(0xAE);       // SSD1306_DISPLAYOFF&#13;" line984="        sendCommand1(0xA4);       // SSD1306_DISPLAYALLON_RESUME&#13;" line985="        sendCommand2(0xD5, 0xF0); // SSD1306_SETDISPLAYCLOCKDIV&#13;" line986="        sendCommand2(0xA8, 0x3F); // SSD1306_SETMULTIPLEX&#13;" line987="        sendCommand2(0xD3, 0x00); // SSD1306_SETDISPLAYOFFSET&#13;" line988="        sendCommand1(0 | 0x0);    // line #SSD1306_SETSTARTLINE&#13;" line989="        sendCommand2(0x8D, 0x14); // SSD1306_CHARGEPUMP&#13;" line990="        sendCommand2(0x20, 0x00); // SSD1306_MEMORYMODE&#13;" line991="        sendCommand3(0x21, 0, 127); // SSD1306_COLUMNADDR&#13;" line992="        sendCommand3(0x22, 0, 63);  // SSD1306_PAGEADDR&#13;" line993="        sendCommand1(0xa0 | 0x1); // SSD1306_SEGREMAP&#13;" line994="        sendCommand1(0xc8);       // SSD1306_COMSCANDEC&#13;" line995="        sendCommand2(0xDA, 0x12); // SSD1306_SETCOMPINS&#13;" line996="        sendCommand2(0x81, 0xCF); // SSD1306_SETCONTRAST&#13;" line997="        sendCommand2(0xd9, 0xF1); // SSD1306_SETPRECHARGE&#13;" line998="        sendCommand2(0xDB, 0x40); // SSD1306_SETVCOMDETECT&#13;" line999="        sendCommand1(0xA6);       // SSD1306_NORMALDISPLAY&#13;" line1000="        sendCommand2(0xD6, 0);    // zoom off&#13;" line1001="        sendCommand1(0xAF);       // SSD1306_DISPLAYON&#13;" line1002="        clear();&#13;" line1003="    }&#13;" line1004="&#13;" line1005="    /**&#13;" line1006="* ---------------ai data parsing-------------------&#13;" line1007="*/&#13;" line1008="    //% block=&quot;블루투스 수신 값: %data 에서 %type 추출&quot;&#13;" line1009="    //% group=&quot;AI 서비스 데이터 활용&quot;&#13;" line1010="    //% weight=5&#13;" line1011="    export function parseUARTUnified(data: string, type: UARTDataType, format: ReturnFormat): any {&#13;" line1012="        if (data == &quot;null&quot; || data == &quot;stop&quot;) {&#13;" line1013="            return format == ReturnFormat.String ? data : -1&#13;" line1014="        }&#13;" line1015="&#13;" line1016="        let v = getValue(data, uartKey(type))&#13;" line1017="&#13;" line1018="        if (format == ReturnFormat.String) return v&#13;" line1019="        let num = parseInt(v)&#13;" line1020="        return isNaN(num) ? -1 : num&#13;" line1021="    }&#13;" line1022="&#13;" line1023="&#13;" line1024="    //% block=&quot;블루투스 수신 값: %data 에서 %color 추출&quot;&#13;" line1025="    //% group=&quot;AI 서비스 데이터 활용&quot;&#13;" line1026="    //% weight=4&#13;" line1027="    export function parseColorUnified(data: string, color: ColorDataType, format: ReturnFormat): any {&#13;" line1028="        if (data == &quot;stop&quot;) {&#13;" line1029="            return format == ReturnFormat.String ? data : -1&#13;" line1030="        }&#13;" line1031="&#13;" line1032="        let w = getValue(data, colorKey(color))&#13;" line1033="&#13;" line1034="        if (format == ReturnFormat.String) return w&#13;" line1035="        let num2 = parseInt(w)&#13;" line1036="        return isNaN(num2) ? -1 : num2&#13;" line1037="    }&#13;" line1038="&#13;" line1039="    // 공통 데이터 추출 함수&#13;" line1040="    function getValue(data: string, key: string): string {&#13;" line1041="        let start = data.indexOf(key)&#13;" line1042="        if (start &lt; 0) return &quot;&quot;&#13;" line1043="        let end = data.length&#13;" line1044="        const keys = [&quot;x&quot;, &quot;y&quot;, &quot;w&quot;, &quot;h&quot;, &quot;d&quot;, &quot;R&quot;, &quot;G&quot;, &quot;B&quot;, &quot;\n&quot;]&#13;" line1045="        for (let r of keys) {&#13;" line1046="            if (r != key) {&#13;" line1047="                const s = data.indexOf(r, start + 1)&#13;" line1048="                if (s &gt;= 0 &amp;&amp; s &lt; end) {&#13;" line1049="                    end = s&#13;" line1050="                }&#13;" line1051="            }&#13;" line1052="        }&#13;" line1053="        return data.substr(start + 1, end - start - 1)&#13;" line1054="    }&#13;" line1055="&#13;" line1056="    // UART 데이터 타입&#13;" line1057="    export enum UARTDataType {&#13;" line1058="        //% block=&quot;X 좌표&quot;&#13;" line1059="        X,&#13;" line1060="        //% block=&quot;Y 좌표&quot;&#13;" line1061="        Y,&#13;" line1062="        //% block=&quot;너비&quot;&#13;" line1063="        W,&#13;" line1064="        //% block=&quot;높이&quot;&#13;" line1065="        H,&#13;" line1066="        //% block=&quot;객체 수&quot;&#13;" line1067="        D&#13;" line1068="    }&#13;" line1069="&#13;" line1070="    // 색상 데이터 타입&#13;" line1071="    export enum ColorDataType {&#13;" line1072="        //% block=&quot;빨강 값&quot;&#13;" line1073="        R,&#13;" line1074="        //% block=&quot;초록 값&quot;&#13;" line1075="        G,&#13;" line1076="        //% block=&quot;파랑 값&quot;&#13;" line1077="        B&#13;" line1078="    }&#13;" line1079="&#13;" line1080="    // 반환 형식&#13;" line1081="    export enum ReturnFormat {&#13;" line1082="        //% block=&quot;문자형&quot;&#13;" line1083="        String,&#13;" line1084="        //% block=&quot;정수형&quot;&#13;" line1085="        Number&#13;" line1086="    }&#13;" line1087="&#13;" line1088="    // 내부 함수: UARTDataType → 문자 키&#13;" line1089="    function uartKey(type: UARTDataType): string {&#13;" line1090="        switch (type) {&#13;" line1091="            case UARTDataType.X: return &quot;x&quot;&#13;" line1092="            case UARTDataType.Y: return &quot;y&quot;&#13;" line1093="            case UARTDataType.W: return &quot;w&quot;&#13;" line1094="            case UARTDataType.H: return &quot;h&quot;&#13;" line1095="            case UARTDataType.D: return &quot;d&quot;&#13;" line1096="            default: return &quot;&quot;&#13;" line1097="        }&#13;" line1098="    }&#13;" line1099="&#13;" line1100="    // 내부 함수: ColorDataType → 문자 키&#13;" line1101="    function colorKey(color: ColorDataType): string {&#13;" line1102="        switch (color) {&#13;" line1103="            case ColorDataType.R: return &quot;R&quot;&#13;" line1104="            case ColorDataType.G: return &quot;G&quot;&#13;" line1105="            case ColorDataType.B: return &quot;B&quot;&#13;" line1106="            default: return &quot;&quot;&#13;" line1107="        }&#13;" line1108="    }&#13;" line1109="&#13;" line1110="    export namespace smbus {&#13;" line1111="        export function writeByte(address: number, register: number, value: number): void {&#13;" line1112="            let temp = pins.createBuffer(2);&#13;" line1113="            temp[0] = register;&#13;" line1114="            temp[1] = value;&#13;" line1115="            pins.i2cWriteBuffer(address, temp, false);&#13;" line1116="        }&#13;" line1117="        export function writeBuffer(address: number, register: number, value: Buffer): void {&#13;" line1118="            let temp2 = pins.createBuffer(value.length + 1);&#13;" line1119="            temp2[0] = register;&#13;" line1120="            for (let index4 = 0; index4 &lt; value.length; index4++) {&#13;" line1121="                temp2[index4 + 1] = value[index4];&#13;" line1122="            }&#13;" line1123="            pins.i2cWriteBuffer(address, temp2, false);&#13;" line1124="        }&#13;" line1125="        export function readBuffer(address: number, register: number, length: number): Buffer {&#13;" line1126="            let temp3 = pins.createBuffer(1);&#13;" line1127="            temp3[0] = register;&#13;" line1128="            pins.i2cWriteBuffer(address, temp3, false);&#13;" line1129="            return pins.i2cReadBuffer(address, length, false);&#13;" line1130="        }&#13;" line1131="        export function readNumber(address: number, register: number, format: NumberFormat = NumberFormat.UInt8LE): number {&#13;" line1132="            let temp4 = pins.createBuffer(1);&#13;" line1133="            temp4[0] = register;&#13;" line1134="            pins.i2cWriteBuffer(address, temp4, false);&#13;" line1135="            return pins.i2cReadNumber(address, format, false);&#13;" line1136="        }&#13;" line1137="        export function unpack(format: string, buffer: Buffer): number[] {&#13;" line1138="            let littleEndian: boolean = true;&#13;" line1139="            let offset: number = 0;&#13;" line1140="            let result3: number[] = [];&#13;" line1141="            let numberFormat: NumberFormat = 0;&#13;" line1142="            for (let charIndex = 0; charIndex &lt; format.length; charIndex++) {&#13;" line1143="                switch (format.charAt(charIndex)) {&#13;" line1144="                    case '&lt;':&#13;" line1145="                        littleEndian = true;&#13;" line1146="                        continue;&#13;" line1147="                    case '&gt;':&#13;" line1148="                        littleEndian = false;&#13;" line1149="                        continue;&#13;" line1150="                    case 'c':&#13;" line1151="                    case 'B':&#13;" line1152="                        numberFormat = littleEndian ? NumberFormat.UInt8LE : NumberFormat.UInt8BE; break;&#13;" line1153="                    case 'b':&#13;" line1154="                        numberFormat = littleEndian ? NumberFormat.Int8LE : NumberFormat.Int8BE; break;&#13;" line1155="                    case 'H':&#13;" line1156="                        numberFormat = littleEndian ? NumberFormat.UInt16LE : NumberFormat.UInt16BE; break;&#13;" line1157="                    case 'h':&#13;" line1158="                        numberFormat = littleEndian ? NumberFormat.Int16LE : NumberFormat.Int16BE; break;&#13;" line1159="                }&#13;" line1160="                result3.push(buffer.getNumber(numberFormat, offset));&#13;" line1161="                offset += pins.sizeOf(numberFormat);&#13;" line1162="            }&#13;" line1163="            return result3;&#13;" line1164="        }&#13;" line1165="    }&#13;" line1166="&#13;" line1167="    initialize();&#13;" line1168="}" numlines="1169"></mutation></block></statement></block></xml>